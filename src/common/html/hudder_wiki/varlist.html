<title>Hudder wiki - Variable list</title>
<body onload="initializeTable()">
<style>
#searchbar {
	width: 20%;
	font-size: 1em;
	padding: 12px 20px 12px 12px;
	border: 1px solid #ddd;
	margin-bottom: 12px;
	color: white;
	background-color: rgb(0, 0, 0);
}
#searchbar::placeholder {
	color: darkgray;
	opacity: 1; /* Firefox */
}
#versionFilter {
	width: 20%;
	font-size: 1em;
	padding: 12px 20px 12px 12px;
	border: 1px solid #ddd;
	margin-bottom: 12px;
	color: white;
	background-color: rgb(0, 0, 0);
}
#versionFilter::placeholder {
	color: darkgray;
	opacity: 1; /* Firefox */
}
</style>
<note>Variables are case insensitive</note>
<br>
<script>

function httpGet(theUrl) {
	// create a new XMLHttpRequest object
	let xmlHttp = new XMLHttpRequest();
	
	// open a GET request with the URL
	xmlHttp.open("GET", theUrl, false);
	
	// send the request
	xmlHttp.send(null);
	
	// return the response as a string
	return xmlHttp.responseText;
}

/**
 * Strip JavaScript‐style comments (//… and /*…*​/) from a JSONC string,
 * then parse it as JSON.
 * Gippity made this BTW
 */
function parseJSONC(jsoncString) {
	// 1. Remove all /* … */ block comments
	const withoutBlockComments = jsoncString.replace(
		/\/\*[\s\S]*?\*\//g,
		''
	);
	
	// 2. Remove all // … line comments
	//    – the [^\n\r]* part grabs everything up to a newline
	const withoutAnyComments = withoutBlockComments.replace(
		/\/\/[^\n\r]*/g,
		''
	);
	
	// 3. Now feed the cleaned-up text to the standard JSON parser
	return JSON.parse(withoutAnyComments);
}

var variables_json = parseJSONC(httpGet("https://raw.githubusercontent.com/NGSpace/hudder/refs/heads/latest_release/src/main/resources/assets/hudder/variables.jsonc"));

document.getElementById("hudder_version").innerText = "This list is updated to Hudder version " + variables_json.hudder_version;

// --- SEMVER UTILS ---
function parseSemver(v) {
  // Accept "v1.2.3", "1.2", "1", "1.2.3-alpha.1"
  if (typeof v !== "string") return null;
  const raw = v.trim();
  if (!raw || raw.toUpperCase() === "UNKNOWN") return null;
  const noPrefix = raw.startsWith("v") || raw.startsWith("V") ? raw.slice(1) : raw;
  const m = noPrefix.match(/^(\d+)(?:\.(\d+))?(?:\.(\d+))?(?:-([0-9A-Za-z.-]+))?(?:\+[0-9A-Za-z.-]+)?$/);
  if (!m) return null;
  return {
    major: Number(m[1]),
    minor: Number(m[2] ?? 0),
    patch: Number(m[3] ?? 0),
    prerelease: (m[4] ?? "") // prerelease exists => lower than release
  };
}
function compareSemver(a, b) {
  // returns -1, 0, 1; invalids sort after valids
  const pa = parseSemver(a), pb = parseSemver(b);
  if (!pa && !pb) return 0;
  if (!pa) return 1;
  if (!pb) return -1;
  if (pa.major !== pb.major) return pa.major - pb.major;
  if (pa.minor !== pb.minor) return pa.minor - pb.minor;
  if (pa.patch !== pb.patch) return pa.patch - pb.patch;
  // prerelease: empty > non-empty (release > prerelease)
  if (!!pa.prerelease !== !!pb.prerelease) return pa.prerelease ? -1 : 1;
  // if both have prerelease, do a simple lexical compare (good enough)
  if (pa.prerelease || pb.prerelease) return pa.prerelease.localeCompare(pb.prerelease, undefined, { numeric: true, sensitivity: "base" });
  return 0;
}
function isVersionLE(rowV, selectedV) {
  const cmp = compareSemver(rowV, selectedV);
  return cmp <= 0;
}
// --- END SEMVER UTILS ---

function updateSearch() {
  // Grab and normalize the user input
  const input = document.getElementById("searchbar");
  let filter = input.value.trim().toUpperCase();

  // NEW: current version filter + checkbox
  const versionFilter = document.getElementById("versionFilter")?.value || "";
  const includePrevious = document.getElementById("includePrevious")?.checked || false;

  // Auto‐correct: if query mentions horse, pig, or llama, switch to "MOUNT"
  const keywords = ["HORSE", "PIG", "LLAMA"];
  if (keywords.some(k => filter.includes(k))) {
    filter = "MOUNT";
    console.log(`Auto-corrected search term to: ${filter}`);
  }

  const table = document.getElementById("var_table");
  const tr = table.getElementsByTagName("tr");
  let anyVisible = false;

  // Loop through all rows
  for (let i = 1; i < tr.length; i++) {
    const tds = tr[i].getElementsByTagName("td");
    let rowMatches = (filter === ""); // if no text filter, start as true

    // Check each cell (text filter)
    if (filter !== "") {
      for (let j = 0; j < tds.length; j++) {
        const txtValue = (tds[j].textContent || tds[j].innerText).trim().toUpperCase();

        if (j === 2) {
          // 3rd column: exact match
          if (txtValue === filter) {
            rowMatches = true;
            break;
          }
        } else {
          // other columns: substring match
          if (txtValue.indexOf(filter) > -1) {
            rowMatches = true;
            break;
          }
        }
      }
    }

    // Version filter
    if (versionFilter) {
      const versionText = (tds[4].textContent || tds[4].innerText).trim();
      const isRowUnknown = versionText.toUpperCase() === "UNKNOWN";
      const isFilterUnknown = versionFilter.toUpperCase() === "UNKNOWN";
    
      let versionMatches;
      if (isFilterUnknown) {
        // Show only rows whose version is Unknown
        versionMatches = isRowUnknown;
      } else if (isRowUnknown) {
        // Exclude Unknown when a specific numeric version is chosen
        versionMatches = false;
      } else {
        // Numeric semver compare
        versionMatches = includePrevious
          ? isVersionLE(versionText, versionFilter)
          : (compareSemver(versionText, versionFilter) === 0);
      }
    
      rowMatches = rowMatches && versionMatches;
    }

    // Show/hide row
    tr[i].style.display = rowMatches ? "" : "none";
    if (rowMatches) anyVisible = true;
  }

  // Not-found messaging (mention both filters if used)
  if (!anyVisible) {
    const parts = [];
    if (input.value.trim() !== "") parts.push(`search "${input.value}"`);
    if (versionFilter) {
      const isFilterUnknown = versionFilter.toUpperCase() === "UNKNOWN";
      parts.push(
        isFilterUnknown
          ? `version "Unknown"`
          : (includePrevious ? `version ≤ "${versionFilter}"` : `version "${versionFilter}"`)
      );
    }
    const msg = parts.length ? parts.join(" + ") : "your filters";
    document.getElementById("res").innerText = "No variable found matching " + msg;
    document.getElementById("searchnotfound").style.display = "";
  } else {
    document.getElementById("searchnotfound").style.display = "none";
  }
}

// Populate the version dropdown with unique versions (semver-sorted), keeping "All versions" first
function populateVersionFilter(versions) {
  const select = document.getElementById("versionFilter");
  if (!select) return;

  // Keep the first "All versions"
  select.innerHTML = "";
  const allOpt = document.createElement("option");
  allOpt.value = "";
  allOpt.textContent = "All versions";
  select.appendChild(allOpt);

  // Separate known semvers and Unknowns
  const known = [];
  let hasUnknown = false;
  for (const v of versions) {
    if (!v || v.toUpperCase() === "UNKNOWN") {
      hasUnknown = true;
    } else {
      known.push(v);
    }
  }

  // Sort using semver (ascending)
  known.sort((a, b) => compareSemver(a, b));

  // Build options
  for (const v of known) {
    const opt = document.createElement("option");
    opt.value = v;
    opt.textContent = v;
    select.appendChild(opt);
  }
  if (hasUnknown) {
    const opt = document.createElement("option");
    opt.value = "Unknown";
    opt.textContent = "Unknown";
    select.appendChild(opt);
  }
}


function initializeTable() {
	var table = (document.getElementById("var_table"));
	var versionSet = new Set();
	for (const type in variables_json) {
		if (type=="hudder_version") continue;
		var typelist = variables_json[type];
		for (const category in typelist) {
			var categorylist = typelist[category];
			for (var i = 0; i<categorylist.length; i++) {
				var value = categorylist[i];
				// Create an empty <tr> element and add it to the 1st position of the table:
				var row = table.insertRow(i+1);
				
				
				if (value.name==undefined) {
					console.log(i)
					console.log(category)
				}
				var name_cell = row.insertCell(0);
				name_cell.innerText = value.name;
				var desc_cell = row.insertCell(1);
				desc_cell.innerText = value.desc;
				var type_cell = row.insertCell(2);
				type_cell.innerText = type;
				var cate_cell = row.insertCell(3);
				cate_cell.innerText = category;
				var version_cell = row.insertCell(4);
				var versionVal = value.version == undefined ? "Unknown" : value.version;
				version_cell.innerText = versionVal;

				versionSet.add(versionVal); // NEW: track unique versions
			}
		}
	}
	console.log("Done loading variable table");
	
	// NEW: build the dropdown after table data is known
	populateVersionFilter(Array.from(versionSet));
	
	var input = document.getElementById('searchbar');
	input.focus();
	input.select();
}

</script>

<input type="text" id="searchbar" onkeyup="updateSearch()" placeholder="Search for a variable...">
	
<label for="versionFilter">Version:</label>
<select id="versionFilter" onchange="updateSearch()">
		<option value="">All versions</option>
</select>

<label style="margin-left:.5rem;">
  <input type="checkbox" id="includePrevious" onchange="updateSearch()">
  Include previous versions
</label>

<table id="var_table">
	<colgroup>
		<col span="1" style="width: 15%;">
		<col span="1" style="width: 50%;">
		<col span="1" style="width: 5%;">
		<col span="1" style="width: 20%;">
		<col span="1" style="width: 5%;">
	</colgroup>

	<tr>
		<th>Function</th>
		<th width="30%">Description</th>
		<th>Type</th>
		<th>Category</th>
		<th>Version</th>
	</tr>
	
	<!-- Secret third option -->
	<tr style="display:none;color: red;text-align: center;" id="searchnotfound">
		<th id="res" colspan="4">No variable found matching that search query</th>
	</tr>
</table>

<br><br><br>
</body>